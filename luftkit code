import numpy as np

def benjamini_hochberg(pvals, alpha=0.05):
    pvals = np.asarray(pvals)
    n = len(pvals)
    order = np.argsort(pvals)
    ranked = pvals[order]
    thresh = alpha * (np.arange(1, n+1) / n)
    below = ranked <= thresh
    if not below.any():
        return np.full(n, False)
    k = np.max(np.where(below))
    cutoff = ranked[k]
    return pvals <= cutoff

def empirical_pvalue(observed, null_samples):
    null_samples = np.asarray(null_samples)
    return (np.sum(null_samples >= observed) + 1)/(len(null_samples)+1)

def harmonic_targets(f0, max_n, include_subharmonics, odd_only):
    targets = []
    for n in range(1, max_n+1):
        if odd_only and n % 2 == 0:
            continue
        targets.append((n, f0*n, 'harmonic'))
    if include_subharmonics:
        for n in range(2, max_n+1):
            if odd_only and n % 2 == 0:
                continue
            targets.append((-n, f0/n, 'subharmonic'))
    return targets

def match_peaks_to_targets(peaks_freq, peaks_z, peaks_q, targets, tol_hz, z_min, q_alpha):
    rows = []
    matches = 0
    for order, tf, typ in targets:
        # find nearest peak
        if len(peaks_freq)==0:
            rows.append([tf, order, typ, 0, '', '', '', ''])
            continue
        idx = np.argmin(np.abs(peaks_freq - tf))
        df = peaks_freq[idx] - tf
        matched = int(abs(df) <= tol_hz and peaks_z[idx] >= z_min and peaks_q[idx] <= q_alpha)
        if matched:
            matches += 1
        rows.append([tf, order, typ, matched, peaks_freq[idx], df, peaks_z[idx], peaks_q[idx]])
    return rows, matches

def rational_targets(f0, ratios):
    out = []
    for r in ratios:
        try:
            p,q = r.split('/')
            p=int(p); q=int(q)
            out.append((r,p,q,(p/q)*f0))
        except:
            continue
    return out

def match_rationals(peaks_freq, peaks_z, peaks_q, targets, tol_hz, z_min, q_alpha):
    rows=[]
    for ratio,p,q,tf in targets:
        if len(peaks_freq)==0:
            rows.append([ratio,p,q,tf,0,'','','',''])
            continue
        idx = np.argmin(np.abs(peaks_freq - tf))
        df = peaks_freq[idx]-tf
        matched = int(abs(df)<=tol_hz and peaks_z[idx] >= z_min and peaks_q[idx] <= q_alpha)
        rows.append([ratio,p,q,tf,matched,peaks_freq[idx],df,peaks_z[idx],peaks_q[idx]])
    return rows

def enrichment_empirical(peaks_freq, peaks_z, peaks_q, n_expected, freq_low, freq_high, tol_hz, z_min, q_alpha, permutations=500):
    if n_expected == 0:
        return 1.0, []
    rng = np.random.default_rng()
    null = []
    arr_freq = np.asarray(peaks_freq)
    arr_z = np.asarray(peaks_z)
    arr_q = np.asarray(peaks_q)
    for _ in range(permutations):
        targets = rng.uniform(freq_low, freq_high, n_expected)
        m=0
        for tf in targets:
            if len(arr_freq)==0: continue
            idx = np.argmin(np.abs(arr_freq - tf))
            df = abs(arr_freq[idx]-tf)
            if df <= tol_hz and arr_z[idx] >= z_min and arr_q[idx] <= q_alpha:
                m+=1
        null.append(m)
    return null
